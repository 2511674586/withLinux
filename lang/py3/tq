#!/usr/bin/python3
# @ref python-cookbook
# @ref http://python3-cookbook.readthedocs.org/zh_CN/latest/c12/p14_launching_daemon_process_on_unix.html
# @file tq
# @brief Task Queue Daemon, and Client utils
# @author Lumin Zhou <cdluminate>
# @license MIT

import os
import sys
import socket
import select
import subprocess
import time
import json # to be replaced with sqlite3
import sqlite3

import atexit
import signal

import logging as log
log.basicConfig(
    format='%(levelno)s %(asctime)s %(process)d %(filename)s:%(lineno)d]'
        +' %(message)s',
    level=log.DEBUG
)

def daemonize(*,
        uid,
        pidfile,
        stdin   = '/dev/null',
        stdout  = '/dev/null',
        stderr  = '/dev/null'):

    if os.path.exists(pidfile):
        raise RuntimeError('Already running')

    # First fork (detaches from parent)
    try:
        if os.fork() > 0:
            raise SystemExit(0)   # Parent exit
    except OSError as e:
        raise RuntimeError('fork #1 failed.')

    os.chdir('/')
    os.umask(0)
    os.setsid()
    # Second fork (relinquish session leadership)
    try:
        if os.fork() > 0:
            raise SystemExit(0)
    except OSError as e:
        raise RuntimeError('fork #2 failed.')

    # Flush I/O buffers
    sys.stdout.flush()
    sys.stderr.flush()

    # Replace file descriptors for stdin, stdout, and stderr
    with open(stdin, 'rb', 0) as f:
        os.dup2(f.fileno(), sys.stdin.fileno())
    with open(stdout, 'ab', 0) as f:
        os.dup2(f.fileno(), sys.stdout.fileno())
    with open(stderr, 'ab', 0) as f:
        os.dup2(f.fileno(), sys.stderr.fileno())

    # Write the PID file
    with open(pidfile,'w') as f:
        print(os.getpid(),file=f)

    # Arrange to have the PID file removed on exit/signal
    atexit.register(lambda: os.remove(pidfile))

    # Signal handler for termination (required)
    def sigterm_handler(signo, frame):
        log.info('recieved SIGTERM, exit.')
        raise SystemExit(1)

    signal.signal(signal.SIGTERM, sigterm_handler)

def tqd(dbfile, pidfile):
    log.info('Tqd started with pid {} uid {}'.format(os.getpid(), str(UID)))

    if not os.path.exists(dbfile):
        tq = sqlite3.connect(dbfile)
        cursor = tq.cursor()
        cursor.execute('create table tq (status, cwd, cmd)')
        cursor.close()
        tq.commit()
        tq.close()
    log.debug('Tqd listening on sqlite3')

    while True:

        #log.debug('    tqd check task queue in sqlite3 ...')
        tq = sqlite3.connect(SQLITE)
        cursor = tq.cursor()
        sql = 'select * from tq where status is null limit 1'
        #log.debug('    sqlite3> {}'.format(sql))
        cursor.execute(sql)
        values = cursor.fetchall() # len(values) may be 0
        cursor.close()
        tq.close()
        if len(values) > 0: # there are works to do
            values = values[0]
            status, cwd, cmd = values[0], values[1], values[2]
            log.info('new task detected, execute next task')
            log.info('    sqlite3> {}'.format(sql))
            log.info('    cwd = {}'.format(cwd))
            log.info('    cmd = {}'.format(cmd))
            # fork:
            #  worker> runnit
            #  master> save pid, waitpid, then update sqlite status
            pid = os.fork()
            if pid > 0: # parent
                log.info('waiting for worker {}...'.format(pid))

                tq = sqlite3.connect(SQLITE)
                sql = 'update tq set status = \'' +str(pid)+ '\' where (status is null) and (cwd =\'' +cwd+ '\') and (cmd = \'' +cmd+ '\') limit 1'
                log.info('    sqlite3> {}'.format(sql))
                tq.execute(sql)
                tq.commit()
                tq.close()

                os.waitpid(-1, 0)
                log.info('worker task complete, update database ...')

                tq = sqlite3.connect(SQLITE)
                sql = 'update tq set status = \'OK\' where (status =\'' +str(pid)+ '\') and (cwd =\'' +cwd+ '\') and (cmd = \'' +cmd+ '\') limit 1'
                tq.execute(sql)
                log.info('    sqlite3> {}'.format(sql))
                tq.commit()
                tq.close()

            else: # worker
                os.chdir(cwd)
                tqout = os.popen(cmd).read()
                with open('tq.out', 'a+') as f:
                    f.write(tqout)
                os._exit(0) # don't remove pidfile! i.e. don't trigger atexit().
        else:
            # there is nothing to do in the queue, just sleep
            # log.debug('    tqd task queue empty ...')
            time.sleep(1)

def Usage (argv0):
    print('Usage: {} {{COMMAND | -- TASK}}'.format(sys.argv[0]), file=sys.stderr)
    print()
    print('  h       -> show usage, and tqd status')
    print('  start   -> start daemon')
    print('  stop    -> stop daemon')
    print('  log     -> dump daemon log to screen')
    print('  ls      -> show current task queue and status')
    print('  clean   -> remove log file')
    print('  purge   -> remove log file and sqlite3 db file')
    print('  -- TASK -> assign TASK (a command line)')
    print()
    print('tq version: 0.0a')

if __name__ == '__main__':
    UID = os.getuid()
    PIDFILE = '/tmp/tqd_{}.pid'.format(str(UID))
    LOGFILE = '/tmp/tqd_{}.log'.format(str(UID))
    SQLITE  = '/tmp/tqd_{}.db'.format(str(UID))

    if len(sys.argv) < 2:
        Usage(sys.argv[0])
        print()
        if os.path.exists(PIDFILE):
            print('tqd is running.')
        else:
            print('tqd is not running.')
        raise SystemExit(1)

    if sys.argv[1] == 'start':
        log.info('starting Tqd ...')
        try:
            daemonize(uid=UID,
                      pidfile=PIDFILE,
                      stdout=LOGFILE,
                      stderr=LOGFILE)
        except RuntimeError as e:
            print(e, file=sys.stderr)
            raise SystemExit(1)

        tqd(SQLITE, PIDFILE)

    elif sys.argv[1] == 'stop':
        if os.path.exists(PIDFILE):
            with open(PIDFILE) as f:
                os.kill(int(f.read()), signal.SIGTERM)
        else:
            log.info('Tqd is NOT running')
            raise SystemExit(1)
    
    elif sys.argv[1] == 'log':
        if os.path.exists(LOGFILE):
            with open(LOGFILE, 'r') as log:
                print(log.read())

    elif sys.argv[1] == 'clean':
        if not os.path.exists(PIDFILE):
            if os.path.exists(LOGFILE):
                os.unlink(LOGFILE)

    elif sys.argv[1] == 'purge':
        if not os.path.exists(PIDFILE):
            if os.path.exists(LOGFILE):
                os.unlink(LOGFILE)
            if os.path.exists(SQLITE):
                os.unlink(SQLITE)

    elif sys.argv[1] == 'ls':
        if not os.path.exists(PIDFILE):
            log.error('Tqd is not running.')
        elif os.path.exists(SQLITE):
            tq = sqlite3.connect(SQLITE)
            cursor = tq.cursor()
            cursor.execute('select * from tq')
            values = cursor.fetchall()
            for item in values:
                #print ('\'%s\''%item[0], '\'%s\''%item[1], '\'%s\''%item[2], sep='\t')
                print (item)
            cursor.close()
            tq.close()

    elif sys.argv[1] == '--':
        pack = {}
        pack['cwd'] = os.getcwd()
        cmd = ' '.join(sys.argv[2:])
        pack['cmd'] = cmd
        log.info('    {}'.format(str(pack)))

        if not os.path.exists(PIDFILE):
            log.error('Tqd is not running.')
        else:
            tq = sqlite3.connect(SQLITE)
            cursor = tq.cursor()
            cursor.execute('insert into tq (cwd, cmd) values (\''
                + pack['cwd']+ '\',\'' + pack['cmd'] + '\')')
            cursor.close()
            tq.commit()
            tq.close()
        log.info('command sent.')

    else:
        log.error('Unknown command {!r}'.format(sys.argv[1]))
        raise SystemExit(1)

